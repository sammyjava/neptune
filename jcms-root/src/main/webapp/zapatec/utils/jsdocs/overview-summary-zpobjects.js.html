<!doctype html public "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<html>
<head>
<title>
Zapatec Utils Overview
</title>
<link rel ="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script>
function asd() {
	
		parent.document.title="zpobjects.js Overview";
	
}
</script>
</head>
<body bgcolor="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> 	<font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top">
<em>
<b>Zapatec Utils</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<center>
	
	   <h2>zpobjects.js</h2>
	
</center>

	


<h4>Summary</h4>
<p>
	
		No overview generated for 'zpobjects.js'<BR/><BR/>
	
</p>

<hr>


    <table border="1" cellpadding="3" cellspacing="0" width="100%">
    <tr bgcolor="#CCCCFF" class="TableHeadingColor">
    <td colspan=2><font size="+2">
    
        <b>Class Summary</b>
    
    </font></td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="Zapatec/SRProp.html">Zapatec.SRProp</a></b></td>
    <td>&nbsp;</td>
    </tr>
    
    </table>
    <hr/> 


<!-- ========== METHOD SUMMARY =========== -->

<!-- ========== END METHOD SUMMARY =========== -->


        <pre class="sourceview"><span class="comment">//$Id: zpobjects.js 6804 2007-03-30 11:43:26Z slip $</span>
<span class="comment">/**
 * This is a constructor for Zapatec Array.
 * It can create new array or extend the given
 * one with some useful methods. You can use
 * it with new opertaor or as simple function.
 * Here is the list of extended methods:
 *    method name   | description
 *  -------------------------------------------------------------------------------------------------
 *   clear          | empties the array and returns itself
 *   compact        | deletes the null and undefined items from resulting array
 *   indexOf        | returns the index of the item with the value pointed
 *   without        | returns array without values pointed as all arguments
 *   remove         | returns array without elements that were under poited indexes.
 *                  | You can pass arguments or you can pass an array.
 * <span class="attrib">@param</span> arr {array} if given this array will be 
 * extended.
 * <span class="attrib">@return</span> {array} extended array.
 */</span>
Zapatec.Array = <span class="reserved">function</span>(arr) {
	<span class="comment">//if array is not given then creating new one</span>
	<span class="reserved">if</span> (!Zapatec.isArray(arr)) {
		var array = [];
		<span class="reserved">for</span>(var i = 0; i &lt; arguments.length; ++i) {
			array.push(arguments[i]);
		}
		arr = array;
	}
	<span class="comment">//copying all internal methods to array instance.</span>
	<span class="comment">//clears the array</span>
	arr.clear = <span class="reserved">function</span>() {
		Zapatec.Array.clear(<span class="reserved">this</span>);
	};
	<span class="comment">//returns compact array</span>
	arr.compact = <span class="reserved">function</span>() {
		var compact = Zapatec.Array.compact(<span class="reserved">this</span>);
		<span class="reserved">return</span> Zapatec.Array(compact);
	};
	<span class="comment">//returns index of element, otherwise -1</span>
	arr.indexOf = <span class="reserved">function</span>(value) {
		<span class="reserved">return</span> Zapatec.Array.indexOf(<span class="reserved">this</span>, value);
	};
	<span class="comment">//returns array without some values</span>
	arr.without = <span class="reserved">function</span>() {
		var args = [].slice.call(arguments, 0);
		args.unshift(<span class="reserved">this</span>);
		var without = Zapatec.Array.without.apply(Zapatec.Array, args);
		<span class="reserved">return</span> Zapatec.Array(without);
	};
	<span class="comment">//returns array without pointed indexes</span>
	arr.remove = <span class="reserved">function</span>() {
		var args = [].slice.call(arguments, 0);
		args.unshift(<span class="reserved">this</span>);
		var cut = Zapatec.Array.remove.apply(Zapatec.Array, args);
		<span class="reserved">return</span> Zapatec.Array(cut);
	};
	<span class="comment">//iterates through array, first argument is iterator</span>
	<span class="comment">//function, second one can switch reverse iteration,</span>
	<span class="comment">//iterator function is passed: index, value, array</span>
	arr.each = <span class="reserved">function</span>(func, reverse) {
		var result;
		<span class="reserved">for</span>(var index = reverse ? <span class="reserved">this</span>.length - 1 : 0; 
		    reverse ? (index &gt;= 0) : (index &lt; <span class="reserved">this</span>.length); 
		    reverse ? --index : ++index) {
				<span class="reserved">if</span> (typeof func == <span class="literal">"function"</span>) {
					result = func(index, <span class="reserved">this</span>[index], <span class="reserved">this</span>);
					<span class="reserved">if</span> (result == <span class="literal">"break"</span>) {
						break;
					}
				}
		}
		<span class="comment">//need a way to return the break indicator</span>
		<span class="reserved">if</span> (result == <span class="literal">"break"</span>) {
			<span class="reserved">return</span> false;
		}
		<span class="reserved">return</span> true;
	};
	<span class="comment">//indicator of Zapatec.Array</span>
	arr.isZpArray = true;
	
	<span class="reserved">return</span> arr;
};

<span class="comment">/**
 * Clears the given array from null and undefined items.
 * <span class="attrib">@param</span> arr {array} array to compact.
 * <span class="attrib">@return</span> {array} cleared array.
 */</span>
Zapatec.Array.compact = <span class="reserved">function</span>(arr) {
	var newArr = [];
	<span class="reserved">for</span>(var item = 0; item &lt; arr.length; ++item) {
		<span class="reserved">if</span> (arr[item] !== null &amp;&amp; typeof arr[item] != <span class="literal">"undefined"</span>) {
			newArr.push(arr[item]);
		}
	}
	<span class="reserved">return</span> newArr;
};

<span class="comment">/**
 * Returns the empty array.
 * <span class="attrib">@param</span> arr {array} array to clear.
 */</span>
Zapatec.Array.clear = <span class="reserved">function</span>(arr) {
	arr.length = 0;
};

<span class="comment">/**
 * Returns the index of the value in the given array.
 * If value was not found returns -1.
 * <span class="attrib">@param</span> arr {array} array to walk through.
 * <span class="attrib">@param</span> value {mixed} value to seek for.
 * <span class="attrib">@return</span> {number} index of found item or -1.
 */</span>
Zapatec.Array.indexOf = <span class="reserved">function</span>(arr, value) {
	<span class="comment">//iterating through items</span>
	<span class="reserved">for</span>(var item = 0; item &lt; arr.length; ++item) {
		<span class="reserved">if</span> (arr[item] === value) {
			<span class="comment">//returning found index</span>
			<span class="reserved">return</span> item;
		}
	}
	<span class="comment">//returning failure.</span>
	<span class="reserved">return</span> -1;
};

<span class="comment">/**
 * Returns the array without pointed items.
 * All the arguments that were passed after
 * arr will be used as values to seek.
 * <span class="attrib">@param</span> arr {array} array to cut.
 * <span class="attrib">@return</span> {array} array without elements which were passed.
 */</span>
Zapatec.Array.without = <span class="reserved">function</span>(arr) {
	var newArr = [], without;
	<span class="comment">//iterating through items</span>
	<span class="reserved">for</span>(var item = 0; item &lt; arr.length; ++item) {
		without = false;
		<span class="reserved">for</span>(var value = 1; value &lt; arguments.length; ++value) {
			<span class="reserved">if</span> (arr[item] === arguments[value]) {
				<span class="comment">//flag that we need to exclude this element</span>
				without = true;
				break;
			}
		}
		<span class="comment">//if not excluding lets push this value to result</span>
		<span class="reserved">if</span> (!without) {
			newArr.push(arr[item]);
		}
	}
	<span class="comment">//returning array.</span>
	<span class="reserved">return</span> newArr;
};

<span class="comment">/**
 * Returns the array without items that were under pointed
 * indexes. Second and next parameters are treated as indexes
 * to remove. You can also pass array of indexes as second argument.
 * <span class="attrib">@param</span> arr {array} array to cut.
 * <span class="attrib">@return</span> {array} array without items with pointed indexes.
 */</span>
Zapatec.Array.remove = <span class="reserved">function</span>(arr) {
	var newArr = [], without, value, start = 1;
	<span class="reserved">if</span> (arguments[1] &amp;&amp; arguments[1].length &amp;&amp; typeof arguments[1] == <span class="literal">"object"</span>) {
		args = arguments[1];
		start = 0;
	} <span class="reserved">else</span> {
		args = arguments;
	}
	<span class="comment">//iterating through items</span>
	<span class="reserved">for</span>(var item = 0; item &lt; arr.length; ++item) {
		without = false;
		<span class="reserved">for</span>(value = start; value &lt; args.length; ++value) {
			<span class="reserved">if</span> (item === args[value]) {
				<span class="comment">//flag that we need to exclude this element</span>
				without = true;
				break;
			}
		}
		<span class="comment">//if not excluding lets push this value to result</span>
		<span class="reserved">if</span> (!without) {
			newArr.push(arr[item]);
		}
	}
	<span class="comment">//returning array.</span>
	<span class="reserved">return</span> newArr;
};

<span class="comment">/**
 * This is a constructor for Zapatec Hash.
 * It can create new hash or extend the given
 * one with some useful methods. You can use
 * it with new opertaor or as simple function.
 * Here is the list of extended methods:
 *    method name   | description
 *  -------------------------------------------------------------------------------------------------
 *   hashRemove     | returns hash without properties pointed as all arguments or array as an argument
 *   hashEach       | iterates through all hash pairs of key and value. Internal methods are skiped.
 *   hashIsEmpty    | returns true if hash has no items. Internal methods are not taken in account.
 *
 * <span class="attrib">@param</span> hash {object} if given this hash will be extended.
 * <span class="attrib">@return</span> {object} extended hash.
 */</span>
Zapatec.Hash = <span class="reserved">function</span>(hash) {
	<span class="comment">//if hash is not given then creating new one</span>
	<span class="reserved">if</span> (!hash || typeof hash != <span class="literal">"object"</span>) {
		hash = {};
	}
	<span class="comment">//copying all internal methods to array instance.</span>
	<span class="comment">//returns hash without pointed properties</span>
	hash.hashRemove = <span class="reserved">function</span>() {
		var args = [].slice.call(arguments, 0);
		args.unshift(<span class="reserved">this</span>);
		var without = Zapatec.Hash.remove.apply(Zapatec.Hash, args);
		<span class="reserved">return</span> Zapatec.Hash(without);
	};
	<span class="comment">//iterating through hash properties, first parameter</span>
	<span class="comment">//is iterator function</span>
	hash.hashEach = <span class="reserved">function</span>(func) {
		<span class="comment">//flag if we should execute iteration function</span>
		var result = null;
		<span class="comment">//looping through all properties</span>
		<span class="reserved">for</span>(var prop in <span class="reserved">this</span>) {
			<span class="comment">//excluding Zapatec.Hash properties</span>
			<span class="reserved">if</span> (prop == <span class="literal">"hashRemove"</span> || prop == <span class="literal">"hashEach"</span> 
			    || prop == <span class="literal">"hashIsEmpty"</span> || prop == <span class="literal">"isZpHash"</span>) {
					continue;
			}
			<span class="comment">//excluding Object properties</span>
			<span class="reserved">if</span> (typeof Object.<span class="reserved">prototype</span>[prop] != <span class="literal">"undefined"</span>) {
				continue;
			}
			<span class="comment">//if this is not Object or Zapatec.Hash property</span>
			<span class="comment">//lets call iteration function.</span>
			result = func(prop, <span class="reserved">this</span>[prop], <span class="reserved">this</span>);
			<span class="reserved">if</span> (result == <span class="literal">"break"</span>) {
				break;
			}
		}
		<span class="comment">//need a way to return the break indicator</span>
		<span class="reserved">if</span> (result == <span class="literal">"break"</span>) {
			<span class="reserved">return</span> false;
		}
		<span class="reserved">return</span> true;
	};
	<span class="comment">//checks if hash is empty</span>
	hash.hashIsEmpty = <span class="reserved">function</span>() {
		var empty = true;
		<span class="reserved">this</span>.hashEach(<span class="reserved">function</span>() {
			empty = false;
			<span class="reserved">return</span> <span class="literal">"break"</span>;
		});
		<span class="reserved">return</span> empty;
	};
	<span class="comment">//indicator of Zapatec.Hash</span>
	hash.isZpHash = true;
	
	<span class="reserved">return</span> hash;
};

<span class="comment">/**
 * Returns the hash without properties which has names
 * pointed as second and other arguments.
 * You can also pass array of strings as second argument.
 * <span class="attrib">@param</span> hash {object} hash to remove property from.
 * <span class="attrib">@return</span> {object} cut hash.
 */</span>
Zapatec.Hash.remove = <span class="reserved">function</span>(hash) {
	var newHash = {}, without, value, start = 1;
	<span class="reserved">if</span> (arguments[1] &amp;&amp; arguments[1].length &amp;&amp; typeof arguments[1] == <span class="literal">"object"</span>) {
		args = arguments[1];
		start = 0;
	} <span class="reserved">else</span> {
		args = arguments;
	}
	<span class="comment">//iterating through items</span>
	<span class="reserved">for</span>(var item in hash) {
		without = false;
		<span class="reserved">for</span>(value = start; value &lt; args.length; ++value) {
			<span class="reserved">if</span> (item === args[value]) {
				<span class="comment">//flag that we need to exclude this element</span>
				without = true;
				break;
			}
		}
		<span class="comment">//if not excluding lets add this value to result</span>
		<span class="reserved">if</span> (!without) {
			newHash[item] = hash[item];
		}
	}
	<span class="comment">//returning hash.</span>
	<span class="reserved">return</span> newHash;
};

<span class="comment">/**
 * Gets the value from the hash tree by given path.
 * Path can include method calls and array indexing.
 * <span class="attrib">@param</span> hash {object} hash to seek in.
 * <span class="attrib">@param</span> path {string} path to the element.
 * <span class="attrib">@return</span> {object} object with two properties:
 *                  - value - value by the path.
 *                  - result - success or failure.
 */</span>
Zapatec.Hash.getByPath = <span class="reserved">function</span>(hash, path) {
	<span class="comment">//if no path - no action</span>
	<span class="reserved">if</span> (!path || typeof path != <span class="literal">"string"</span>) {
		Zapatec.Log({description : <span class="literal">"Not a path passed to Zapatec.Hash.getByPath function!"</span>, type : <span class="literal">"warning"</span>});
		<span class="reserved">return</span> {
			result : false
		};
	}
	<span class="comment">//splitting the path</span>
	var paths = path.split(<span class="literal">"."</span>);
	<span class="comment">//if no items splitted then something is wrong</span>
	<span class="reserved">if</span> (!paths.length) {
		Zapatec.Log({description : <span class="literal">"Wrong path passed to Zapatec.Hash.getByPath function!"</span>, type : <span class="literal">"warning"</span>});
		<span class="reserved">return</span> {
			result : false
		};
	}
	<span class="comment">//iterateing through each item</span>
	var item = 0;
	var value = hash;
	var name = <span class="literal">""</span>;
	var scope = null;
	<span class="reserved">while</span>(paths[item]) {
		<span class="comment">//if there is still part of the path current element can not be null</span>
		<span class="reserved">if</span> (value === null || typeof value == <span class="literal">"undefined"</span>) {
			Zapatec.Log({description : <span class="literal">"Incorrect path passed to Zapatec.Hash.getByPath function!"</span>, type : <span class="literal">"warning"</span>});
			<span class="reserved">return</span> {
				result : false
			};
		}
		<span class="comment">//getting property name</span>
		name = paths[item].replace(/(\(\)|\[[^\[\]]+\])+/, <span class="literal">""</span>);
		try {
			<span class="comment">//saving the parent object as scope for its methods if there are any</span>
			scope = value;
			<span class="comment">//getting the property value</span>
			value = value[name];
		} catch (e) {
			Zapatec.Log({description : <span class="literal">"Incorrect path passed to Zapatec.Hash.getByPath function!"</span>, type : <span class="literal">"warning"</span>});
			<span class="reserved">return</span> {
				result : false
			};
		}
		<span class="comment">//taking the rest part to seek for array indexes or method execution brackets</span>
		paths[item] = paths[item].replace(name, <span class="literal">""</span>);
		<span class="comment">//cyclically getting the value by array indexes or method execution</span>
		<span class="comment">//there can be many of the in one property name</span>
		<span class="reserved">while</span> (paths[item] != <span class="literal">""</span>) {
			<span class="comment">//getting first one</span>
			name = paths[item].match(/(\(\)|\[[^\[\]]+\])/)[1];
			<span class="comment">//if it is method lets try to execute it</span>
			<span class="reserved">if</span> (name &amp;&amp; /\(\)$/.test(name)) {
				try {
					<span class="comment">//we use parent object scope or if its not a direst method</span>
					<span class="comment">//but just a function we use itself as a scope</span>
					value = value.call(scope || value);
					<span class="comment">//scope becomes null until we get another property by name</span>
					scope = null;
				} catch (e) {
					Zapatec.Log({description : <span class="literal">"Incorrect path passed to Zapatec.Hash.getByPath function!"</span>, type : <span class="literal">"warning"</span>});
					<span class="reserved">return</span> {
						result : false
					};
				}
			} <span class="reserved">else</span> <span class="reserved">if</span> (name &amp;&amp; /\[[<span class="literal">"']?[^\[\]"</span><span class="literal">']+["'</span>]?\]$/.test(name)) {<span class="comment">// if this is an array lets take its item</span>
				try {
					<span class="comment">//taking the item by index</span>
					value = value[name.match(/\[[<span class="literal">"']?([^\[\]"</span><span class="literal">']+)["'</span>]?\]/)[1]];
					<span class="comment">//scope becomes null until we get another property by name</span>
					scope = null;
				} catch (e) {
					Zapatec.Log({description : <span class="literal">"Incorrect path passed to Zapatec.Hash.getByPath function!"</span>, type : <span class="literal">"warning"</span>});
					<span class="reserved">return</span> {
						result : false
					};
				}
			}
			<span class="comment">//removing index or brackets from the prop path</span>
			paths[item] = paths[item].replace(name, <span class="literal">""</span>);
		}
		++item;
	}
	<span class="reserved">if</span> (typeof value == <span class="literal">"undefined"</span>) {
		Zapatec.Log({description : <span class="literal">"Incorrect path passed to Zapatec.Hash.getByPath function!"</span>, type : <span class="literal">"warning"</span>});
		<span class="reserved">return</span> {
			result : false
		};
	}
	<span class="reserved">return</span> {
		result : true,
		value : value
	};
};

<span class="comment">/**
 * Sets the value to the hash tree by given path.
 * Path can include method calls and array indexing.
 * <span class="attrib">@param</span> hash {object} hash to set in.
 * <span class="attrib">@param</span> path {string} path to the element.
 * <span class="attrib">@param</span> val {mixed} value to set.
 * <span class="attrib">@return</span> {boolean} true if success, otherwise false.
 */</span>
Zapatec.Hash.setByPath = <span class="reserved">function</span>(hash, path, val) {
	<span class="comment">//if no path - no action</span>
	<span class="reserved">if</span> (!path || typeof path != <span class="literal">"string"</span>) {
		Zapatec.Log({description : <span class="literal">"Not a path passed to Zapatec.Hash.setByPath function!"</span>, type : <span class="literal">"warning"</span>});
		<span class="reserved">return</span> false;
	}
	<span class="comment">//splitting the path</span>
	var paths = path.split(<span class="literal">"."</span>);
	<span class="comment">//if no items splitted then something is wrong</span>
	<span class="reserved">if</span> (!paths.length) {
		Zapatec.Log({description : <span class="literal">"Wrong path passed to Zapatec.Hash.setByPath function!"</span>, type : <span class="literal">"warning"</span>});
		<span class="reserved">return</span> false;
	}
	<span class="comment">//taking last item in path (splitted by '.')</span>
	var lastItem = paths[paths.length - 1];
	var obj = hash;
	<span class="comment">//making the rest of the path available for</span>
	<span class="comment">//Zapatec.Hash.getByPath</span>
	var getPath = paths.slice(0, -1).join(<span class="literal">"."</span>);
	<span class="comment">//if there are array indexes lets save just the last one</span>
	<span class="comment">//as the last item and add the rest to the getPath</span>
	var arrIndexReg = /\[[^\[\]]+\]$/;
	<span class="reserved">if</span> (arrIndexReg.test(lastItem)) {
		getPath += (getPath == <span class="literal">""</span> ? <span class="literal">""</span> : <span class="literal">"."</span>) + lastItem.replace(arrIndexReg, <span class="literal">""</span>);
		lastItem = lastItem.match(/\[[<span class="literal">"']?([^\[\]"</span><span class="literal">']+)["'</span>]?\]$/)[1];
	}
	<span class="comment">//seeking the object property of which we need to set</span>
	<span class="reserved">if</span> (getPath != <span class="literal">""</span>) {
		var obj = Zapatec.Hash.getByPath(hash, getPath).value;
	}
	<span class="comment">//trying to set the value</span>
	try {
		obj[lastItem] = val;
	} catch (e) {
		Zapatec.Log({description : <span class="literal">"Incorrect path passed to Zapatec.Hash.setByPath function!"</span>, type : <span class="literal">"warning"</span>});
		<span class="reserved">return</span> false;
	}
	<span class="reserved">return</span> true;
};

<span class="comment">/** 
 * Returns true if this is HTML element.
 * return {boolean} true if HTML element, otherwise false.
 */</span>
Zapatec.isHtmlElement = <span class="reserved">function</span>(el) {
	<span class="reserved">if</span> (!el || el.nodeType != 1) {
		<span class="reserved">return</span> false;
	}
	
	<span class="reserved">return</span> true;
};

<span class="comment">/**
 * Returns true if object has sizable interface.
 * return {boolean} true if sizable, otherwise false.
 */</span>
Zapatec.isSizableObj = <span class="reserved">function</span>(obj) {
	<span class="reserved">if</span> (obj &amp;&amp; obj.hasInterface &amp;&amp; obj.hasInterface(<span class="literal">"Zapatec.Sizable"</span>)) {
		<span class="reserved">return</span> true;
	}
	
	<span class="reserved">return</span> false;
};

<span class="comment">/**
 * Returns true if object has movable interface.
 * return {boolean} true if sizable, otherwise false.
 */</span>
Zapatec.isMovableObj = <span class="reserved">function</span>(obj) {
	<span class="reserved">if</span> (obj &amp;&amp; obj.hasInterface &amp;&amp; obj.hasInterface(<span class="literal">"Zapatec.Movable"</span>)) {
		<span class="reserved">return</span> true;
	}
	
	<span class="reserved">return</span> false;
};

<span class="comment">/**
 * Returns true if object is an array.
 * return {boolean} true if array, otherwise false.
 */</span>
Zapatec.isArray = <span class="reserved">function</span>(arr) {
	<span class="reserved">if</span> (arr &amp;&amp; typeof arr == <span class="literal">"object"</span> &amp;&amp; arr.constructor == Array) {
		<span class="reserved">return</span> true;
	}
	
	<span class="reserved">return</span> false;
};

<span class="comment">/**
 * Returns true if object is a Date object.
 * return {boolean} true if Date object, otherwise false.
 */</span>
Zapatec.isDate = <span class="reserved">function</span>(date) {
	<span class="reserved">if</span> (date &amp;&amp; typeof date == <span class="literal">"object"</span> &amp;&amp; date.constructor == Date) {
		<span class="reserved">return</span> true;
	}
	
	<span class="reserved">return</span> false;
};

<span class="comment">/**
 * object for saving and restoring properties of the given object - SRProp (Save Restore Object Properties)
 * <span class="attrib">@param</span> obj [object] - object to work with
 * this class adds methods to any given object which enable to save and restore properties using following
 * \code
 *   var object = {};
 *   ob = new Zapatec.SRProp(obj);
 *   object.prop = "";
 *   ob.saveProp("prop");
 *   object.prop = "ttt";
 *	 ob.restoreProp("prop");
 *   ob.restoreAll();
 * \endcode
 */</span>
Zapatec.SRProp = <span class="reserved">function</span>(obj) {
	<span class="comment">//storeing of an object to inspect</span>
	<span class="reserved">this</span>.obj = obj;
	<span class="comment">//array of stored properties</span>
	<span class="reserved">this</span>.savedProps = new Zapatec.Hash();
	<span class="comment">//giving the object itself the refference to SRProp obj</span>
	Zapatec.Utils.createProperty(obj, <span class="literal">"restorer"</span>, <span class="reserved">this</span>);
}

<span class="comment">/**
 * Returns the hash of the saved properties. This method can be easily
 * overwritten for extending object.
 * <span class="attrib">@return</span> {object} object containing all saved properties.
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.getSavedProps = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.savedProps;
};

<span class="comment">/**
 * Returns the object we are working with.
 * <span class="attrib">@return</span> {object} object ot work with.
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.getObject = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.obj;
};

<span class="comment">/**
 * Saves the named property to savedProp array
 * You should not overwrite this method as it is core of the object.
 * <span class="attrib">@param</span> propName [string] - name of the property to save - can be the followin "prop", "level1.level2" and so on.
 * <span class="attrib">@return</span> true if successful, otherwise false
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.saveProp = <span class="reserved">function</span> (propName) {
	<span class="comment">//property name should definately be string, I think :)</span>
	<span class="reserved">if</span> (typeof propName != <span class="literal">"string"</span>) {
		<span class="reserved">return</span> false;
	}
	<span class="comment">//getting the value of the property</span>
	var value = Zapatec.Hash.getByPath(<span class="reserved">this</span>.getObject(), propName);
	<span class="comment">//checking if method doesn't failed</span>
	<span class="reserved">if</span> (value.result) {
		<span class="reserved">if</span> (typeof <span class="reserved">this</span>.getProp(propName) != <span class="literal">"undefined"</span>) {
			var prop = <span class="reserved">this</span>.getSavedProps()[propName] = Zapatec.Array(<span class="reserved">this</span>.getSavedProps()[propName]);
			prop.push(value.value);
			prop.combination = true;
			Zapatec.Log({description : <span class="literal">"The property '"</span> + propName + <span class="literal">"' now contains more than one value!"</span>, type : <span class="literal">"warning"</span>});
		} <span class="reserved">else</span> {
			<span class="comment">//if not saving value to the table</span>
			<span class="reserved">this</span>.getSavedProps()[propName] = value.value;
		}
		<span class="comment">//returning success</span>
		<span class="reserved">return</span> true;
	} <span class="reserved">else</span> {
		<span class="comment">//returning failure</span>
		<span class="reserved">return</span> false;
	}
}

<span class="comment">/**
 * Saves the named properties to savedProp array
 * You should not overwrite this method as it is core of the object.
 * <span class="attrib">@param</span> can be any set of params, but only strings will be parsed.
 * <span class="attrib">@return</span> an array of saved properties names
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.saveProps = <span class="reserved">function</span> () {
	<span class="comment">//this array will store a set of really saved properties</span>
	var result = [];
	<span class="reserved">for</span>(var i = 0; i &lt; arguments.length; ++i) {
		<span class="reserved">if</span> (<span class="reserved">this</span>.saveProp(arguments[i])) {
			<span class="comment">//if saved successfuly lets push propety name</span>
			<span class="comment">//to result array.</span>
			result.push(arguments[i]);
		}
	}
	<span class="reserved">return</span> result;
}

<span class="comment">/**
 * Restores the named property from savedProp array.
 * You should not overwrite this method as it is core of the object.
 * <span class="attrib">@param</span> propName [string] - name of the property to restore - can be the followin "prop", "level1.level2" and so on.
 * <span class="attrib">@return</span> true if successful, otherwise false
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.restoreProp = <span class="reserved">function</span> (propName) {
	<span class="comment">//property name should definately be string, I think :)</span>
	<span class="reserved">if</span> (typeof propName != <span class="literal">"string"</span> || typeof <span class="reserved">this</span>.getSavedProps()[propName] == <span class="literal">"undefined"</span>) {
		<span class="reserved">return</span> false;
	}
	var prop = <span class="reserved">this</span>.getSavedProps()[propName];
	var combination = false, nextSibling = null;
	<span class="reserved">if</span> (Zapatec.isArray(prop) &amp;&amp; prop.combination) {
		prop = prop[prop.length - 1];
		combination = true;
	}
	<span class="comment">//Its a workaround for HTML properties such as parentNode to be handled correctly</span>
	<span class="reserved">if</span> (propName.match(/parentNode$/) !== null &amp;&amp; prop &amp;&amp; typeof prop == <span class="literal">"object"</span> &amp;&amp; prop.appendChild) {
		nextSibling = <span class="reserved">this</span>.getSavedProps()[propName.replace(/parentNode/, <span class="literal">"nextSibling"</span>)] || null;
		<span class="reserved">if</span> (nextSibling &amp;&amp; nextSibling.parentNode == prop) {
			prop.insertBefore(<span class="reserved">this</span>.getObject(), nextSibling);
		} <span class="reserved">else</span> {
			prop.appendChild(<span class="reserved">this</span>.getObject());
		}
		<span class="comment">//removing nextSibling property.</span>
		<span class="reserved">this</span>.savedProps = <span class="reserved">this</span>.getSavedProps().hashRemove(propName.replace(/parentNode/, <span class="literal">"nextSibling"</span>));
	} <span class="reserved">else</span> {
		<span class="comment">//restoreing property</span>
		<span class="reserved">if</span> (!Zapatec.Hash.setByPath(<span class="reserved">this</span>.getObject(), propName, prop)) {
			<span class="reserved">return</span> false;
		}
	}
	<span class="comment">//and now free the position in the hash as the property was restored</span>
	<span class="reserved">if</span> (!combination) {
		<span class="reserved">this</span>.savedProps = <span class="reserved">this</span>.getSavedProps().hashRemove(propName);
	} <span class="reserved">else</span> {
		prop = <span class="reserved">this</span>.getSavedProps()[propName];
		<span class="reserved">this</span>.getSavedProps()[propName] = Zapatec.Array.without(prop, prop.length - 1);
	}
	
	<span class="reserved">return</span> true;
}

<span class="comment">/**
 * Restores the named properties from savedProp array
 * You should not overwrite this method as it is core of the object.
 * <span class="attrib">@param</span> can be any set of params, but only strings will be parsed.
 * <span class="attrib">@return</span> true if successful, otherwise false
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.restoreProps = <span class="reserved">function</span> (propName) {
	<span class="comment">//this array will store a set of really restored properties</span>
	var result = [];
	<span class="reserved">for</span>(var i = 0; i &lt; arguments.length; ++i) {
		<span class="reserved">if</span> (<span class="reserved">this</span>.restoreProp(arguments[i])) {
			<span class="comment">//if restored successfuly lets push propety name</span>
			<span class="comment">//to result array.</span>
			result.push(arguments[i]);
		}
	}
	<span class="reserved">return</span> result;
}

<span class="comment">/**
 * Restores all properties from the savedProp array
 * You should not overwrite this method as it is core of the object.
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.restoreAll = <span class="reserved">function</span>() {
	<span class="comment">//just iterating through all saved proerties and restoreing them</span>
	var self = <span class="reserved">this</span>;
	<span class="reserved">this</span>.getSavedProps().hashEach(<span class="reserved">function</span>(i) {
		self.restoreProp(i);
	});
}

<span class="comment">/**
 * Gets property value by name from the savedProp array
 * You should not overwrite this method as it is core of the object.
 * <span class="attrib">@param</span> propName [string] - name of the property to get - can be the followin "prop", "level1.level2" and so on.
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.getProp = <span class="reserved">function</span>(propName) {
	<span class="comment">//Should I expalin this? :)</span>
	<span class="reserved">return</span> <span class="reserved">this</span>.getSavedProps()[propName];
}

<span class="comment">/**
 * Checks if hash of saved properties is empty.
 * <span class="attrib">@return</span> {boolean} true if there are no saved properties,
 * otherwise false.
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.isEmpty = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.getSavedProps().hashIsEmpty();
};

<span class="comment">/**
 * Destroys an object.
 */</span>
Zapatec.SRProp.<span class="reserved">prototype</span>.destroy = <span class="reserved">function</span>() {
	<span class="comment">//destroing cross-reference</span>
	<span class="reserved">this</span>.getObject().restorer = null;
	<span class="comment">//deleteing each property of the object</span>
	<span class="reserved">for</span>(var iProp in <span class="reserved">this</span>) {
		<span class="reserved">this</span>[iProp] = null;
	}
	
	<span class="reserved">return</span> null;
};

<span class="comment">/**
 * Command event interface. It lets you controll
 * the listeners execution, like stoping, re-executing.
 * It is thought that implementing object inherits
 * Zapatec.EventDriven.
 */</span>
Zapatec.CommandEvent = {};

<span class="comment">/**
 * New fireEvent method to fit new functionality.
 * <span class="attrib">@param</span> strEvent [string] - event name.
 */</span>
Zapatec.CommandEvent.fireEvent = <span class="reserved">function</span>(strEvent) {
	<span class="comment">//checking if there is such event</span>
	<span class="reserved">if</span> (!<span class="reserved">this</span>.events[strEvent]) {
		<span class="reserved">return</span>;
	}
	<span class="comment">//getting listeners</span>
	var arrListeners = <span class="reserved">this</span>.events[strEvent].listeners.slice();
	<span class="comment">//clearing previously returned value</span>
	<span class="reserved">this</span>._setReturnedValue(null);
	<span class="comment">//enabling event propogation.</span>
	<span class="reserved">this</span>._setEventPropagation(true);
	<span class="reserved">for</span> (var iListener = 0; iListener &lt; arrListeners.length; iListener++) {
		<span class="comment">// Remove first argument</span>
		var arrArgs = [].slice.call(arguments, 1);
		<span class="comment">// Call in scope of this object</span>
		arrListeners[iListener].apply(<span class="reserved">this</span>, arrArgs);
		<span class="comment">//getting the returned result</span>
		var result = <span class="reserved">this</span>._getReturnedValue();
		<span class="comment">//if needed we stop propogation</span>
		<span class="reserved">if</span> (!<span class="reserved">this</span>._getEventPropagation()) {
			<span class="reserved">return</span> result;
		}
		<span class="comment">//proceeding the returned value</span>
		<span class="reserved">if</span> (result == <span class="literal">"re-execute"</span>) {
			<span class="reserved">this</span>.fireEvent(strEvent);
			break;
		} <span class="reserved">else</span> <span class="reserved">if</span> (result == <span class="literal">"parent-re-execute"</span>) {
			<span class="reserved">return</span> result;
		}
	}
	<span class="comment">//returning value</span>
	<span class="reserved">return</span> <span class="reserved">this</span>._getReturnedValue();
};

<span class="comment">/**
 * This method can be used by listeners to return some value.
 * <span class="attrib">@param</span> val {mixed} any value to return.
 */</span>
Zapatec.CommandEvent.returnValue = <span class="reserved">function</span>(val) {
	<span class="reserved">this</span>._setReturnedValue(val);
};

<span class="comment">/**
 * Sets returned value to internal variable.
 * <span class="attrib">@param</span> val {mixed} value to set.
 */</span>
Zapatec.CommandEvent._setReturnedValue = <span class="reserved">function</span>(val) {
	<span class="reserved">this</span>.returnedValue = val;
};

<span class="comment">/**
 * Gets returned value from internal variable.
 * <span class="attrib">@return</span> {mixed} value.
 */</span>
Zapatec.CommandEvent._getReturnedValue = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.returnedValue;
};

<span class="comment">/**
 * Stops the chain of execution of event listenrs.
 */</span>
Zapatec.CommandEvent.stopPropagation = <span class="reserved">function</span>() {
	<span class="reserved">this</span>._setEventPropagation(false);
};

<span class="comment">/**
 * Saves propgation state to internal variable.
 * <span class="attrib">@param</span> on {boolean} true to turn on, false to turn off.
 */</span>
Zapatec.CommandEvent._setEventPropagation = <span class="reserved">function</span>(on) {
	<span class="reserved">this</span>.eventPropagation = on;
};

<span class="comment">/**
 * Gets propgation state from internal variable.
 * <span class="attrib">@return</span> {boolean} true if turned on, otherwise false.
 */</span>
Zapatec.CommandEvent._getEventPropagation = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.eventPropagation;
};

<span class="comment">/**
 * The object working with global controlled events.
 */</span>
Zapatec.GlobalEvents = new Zapatec.EventDriven();
Zapatec.implement(Zapatec.GlobalEvents, <span class="literal">"Zapatec.CommandEvent"</span>);
Zapatec.GlobalEvents.init();</pre>
	<hr>



<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> <font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top"><em>
<b>Zapatec Utils</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<font size="-1">

</font>
<div class="jsdoc_ctime">Documentation generated by <a href="http://jsdoc.sourceforge.net/" target="_parent">JSDoc</a> on Thu May 21 12:19:24 2009</div>
</body>
</html>
